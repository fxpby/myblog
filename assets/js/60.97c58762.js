(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{466:function(e,v,_){"use strict";_.r(v);var t=_(32),s=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"http-三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-三次握手"}},[e._v("#")]),e._v(" HTTP 三次握手")]),e._v(" "),_("h2",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[e._v("#")]),e._v(" 三次握手")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://fxpby.oss-cn-beijing.aliyuncs.com/blogImg/http/three-times-shake-hands.png",alt:"shake-hands"}})]),e._v(" "),_("p",[e._v("刚开始的时候客户端处于 "),_("code",[e._v("Closed")]),e._v(" 状态， 服务端处于 "),_("code",[e._v("Listen")]),e._v(" 状态")]),e._v(" "),_("h3",{attrs:{id:"第一次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一次握手"}},[e._v("#")]),e._v(" 第一次握手")]),e._v(" "),_("p",[e._v("客户端给服务端发送一个 "),_("code",[e._v("SYN 报文")]),e._v(", 首部的同步位位码 "),_("code",[e._v("SYN=1")]),e._v(", 随机产生初始序号 "),_("code",[e._v("seq number=x")]),e._v(" 的数据包到服务器，服务端根据 "),_("code",[e._v("SYN=1")]),e._v(" 知道客户端要求建立联机.\n"),_("code",[e._v("SYN=1")]),e._v(" 的报文段不能携带数据，需要消耗掉一个序号，会让下一次传输的 "),_("code",[e._v("packet seq")]),e._v(" 增加 "),_("code",[e._v("1")]),e._v("，"),_("code",[e._v("ACK")]),e._v(" 的传输不会让下一次的传输 "),_("code",[e._v("packet seq")]),e._v(" 增加 "),_("code",[e._v("1")]),e._v("\n客户端进程处于 SYN-SENT（同步已发送）状态")]),e._v(" "),_("blockquote",[_("p",[e._v("SYN: 同步序列编号（Synchronize Sequence Numbers）, 是一个标志位，代表创建请求的数据包\nACK: acknowledgement 确认号")])]),e._v(" "),_("h3",{attrs:{id:"第二次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二次握手"}},[e._v("#")]),e._v(" 第二次握手")]),e._v(" "),_("p",[e._v("服务端接收到客户端的 SYN 报文之后需要确认联机信息，服务端开启一个 TCP 的 socket 端口，向客户端发送 确认号 ack 为"),_("code",[e._v("客户端的 seq+1")]),e._v(", "),_("code",[e._v("SYN=1")]),e._v(", "),_("code",[e._v("随机产生的序号 seq=y")]),e._v(", "),_("code",[e._v("ACK=1")]),e._v(" 的包\n这个报文段也不能携带数据，消耗一个序号\n服务端进程处于 SYN-RCVD（同步收到）状态")]),e._v(" "),_("h3",{attrs:{id:"第三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三次握手"}},[e._v("#")]),e._v(" 第三次握手")]),e._v(" "),_("p",[e._v("客户端接收到服务端返回的 SYN 报文之后，会检查 "),_("code",[e._v("确认号ack")]),e._v(" 是否正确，即是否为"),_("code",[e._v("第一次发送的 seq+1")]),e._v(", 确认报文段 位码"),_("code",[e._v("ACK=1")]),e._v("， 正确的话客户端会再发送 "),_("code",[e._v("ACK=上一次服务端返回的 seq+1")]),e._v(", 此时客户端进入 "),_("code",[e._v("ESTABLISHED状态")]),e._v(" 服务端收到后确认 "),_("code",[e._v("seq")]),e._v(" 和 "),_("code",[e._v("ACK=1")]),e._v("，服务端也处于"),_("code",[e._v("ESTABLISHED状态")]),e._v("，正确的话双方连接建立成功")]),e._v(" "),_("h2",{attrs:{id:"为什么要建立三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么要建立三次握手"}},[e._v("#")]),e._v(" 为什么要建立三次握手")]),e._v(" "),_("ul",[_("li",[e._v("防止服务端开启一些无用的连接，网络传输会受到影响，比如第二次握手数据包丢失，客户端就一直没有接收到服务器返回的数据，客户端可能有一些超时设置，超时后就关闭了连接，去创建新的连接请求，服务端此时还处于一个等待状态，这个端口就一直处于开启状态，导致服务器资源开销。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);