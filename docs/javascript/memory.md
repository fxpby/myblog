---
id: memory
title: 内存管理
tags:
  - 内存
---

## 为什么要管理内存

### 减少浏览器负担

内存过大会让浏览器压力过大，导致浏览器卡顿

### Node 端 - 做服务

内存如果不够，服务就会中断

## 内存的数据存储

### 栈内存

线性的，后进先出

### 堆内存

非线性，不连续的

### 存储普通类型的变量 - 栈内存

```js
let a = 1
let b = 2
```

- 先入栈 a-123
- 再入栈 b-10

变量直接指向值，变量和值放在一起

### 存储引用类型的变量 - 堆栈

```js
let a = { a1: 123 }
let b = a
let c = [1, 2, 3]
let d = function() { console.log(123) }
{ a2: 666 }
```

- 声明引用类型变量 a 的时候，先在堆内存中开辟一个地址存放变量（变量本体），再把这个地址赋值给变量，即入栈 a-0x00000000
- a b 指向同一地址，所以入栈 b-0x00000000
- 同声明 a, 入栈 c-0x00000005
- 同声明 a, 入栈 d-0x00000008
- 直接定义一个引用类型，在堆内存中开辟一个地址存放变量（变量本体）

## V8 内存的管理

### V8到底有多大

- `64 位`下是`1.4G（标准）`
- `32 位`下是 `700MB （标准）`
- 根据浏览器不同会有些许扩容
- 新版本 Node 也会有自动调用 C++ 内存进行内扩容（动态扩容）

### 新生代和老生代

比如我们 `64 位` `1.4G` 的内存，分为两块

- 新生代：短时间存活的新变量会存在新生代中，新生代的内存量极小，`64 位`下大概是 `32MB`, `32 位`则减半。新生代平均分成两块相等的内存空间，叫做`semispace`，每块内存大小`8MB（32位）`或`16MB（64位）`
- 老生代：存活时间比较长的变量会转存到老生代，老生代占据了几乎所有内存（常驻），`64 位`下大概是 `1400MB`

#### 新生代

`新生代`使用 `Scavenge GC 垃圾回收算法`，该算法实现时主要采用 `Cheney 算法`。主要处理`存活周期短`的对象中的可访问对象。

`Cheney 算法`使用了 `semi-space 半空间`的设计，将内存一分为二，始终只使用一半的空间，一块 `From-Space` 是使用空间，另一块 `To-Space` 是空闲空间

```js
|<- 新生代->|<-     老生代     ->|
|-----|-----|--------------------|
 From   To
```

- 内存先进入 `From`（新生代在 `From` 中分配对象）
- 等到 `From` 满了之后，新生代的 `GC` 会启动（在垃圾回收阶段检查并按需复制 `From` 中可访问对象到 `To` 或老生代）
- 释放掉 `From` 中一些不再使用的内存（不可访问对象占用的内存空间）
- 再将 `From` 和 `To` 的进行互换，即 `From => To`, `To => From`

如果一个对象经历两次新生代的更替还没有被回收，就需要进入`老生代`
如果一个对象在 `To` 中的内存占比超过 25%，在第一次更替时就直接进入`老生代`

#### 老生代

##### Mark-Sweep - 标记清除

标记清除，分为标记和清除两个阶段

- 标记阶段：遍历所有可访问对象，`GC` 会从一组已知的对象指针（称为根集，包括执行堆栈和全局对象等）中，进行递归标记可访问存活的对象
- 清除阶段：清除没有被标记的对象，将不可访问的对象留下的内存空间，添加到空闲链表的过程。未来为新对象分配内存时，可以从空闲链表中进行再分配

##### Mark-Compact - 整理

主要处理`存活周期长`的对象中的不可访问对象, 主要使用 `Cheney 复制算法`

清除完对象后，内存内部的对象就不连续了，这样无法很好的利用内存地址（需要连续的内存），比如大的对象无法塞入刚释放的小内存中，提前触发垃圾回收

`Mark-Compact` 移动这些对象，让他们变紧凑，即标记清除对象后内存空间会出现内存碎片，当碎片超过一定限制后会启动压缩算法，将存活的可访问对象向内存一端移动，直到所有对象都移动完成，然后清理不需要的内存

> 因为新生代中占少数的是可访问对象，老生代中占少数的是不可访问对象，所以 Scavenge GC 垃圾回收算法 和 Mark-Compact 算法配合十分高效
